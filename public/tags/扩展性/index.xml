<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>扩展性 on KingdeGuo&#39;s Blog</title>
    <link>http://localhost:49666/tags/%E6%89%A9%E5%B1%95%E6%80%A7/</link>
    <description>Recent content in 扩展性 on KingdeGuo&#39;s Blog</description>
    <generator>Hugo</generator>
    <language>zh-CN</language>
    <lastBuildDate>Fri, 05 Sep 2025 22:27:00 +0800</lastBuildDate>
    <atom:link href="http://localhost:49666/tags/%E6%89%A9%E5%B1%95%E6%80%A7/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>面向 scaling 编程</title>
      <link>http://localhost:49666/2025/09/05/%E9%9D%A2%E5%90%91-scaling-%E7%BC%96%E7%A8%8B/</link>
      <pubDate>Fri, 05 Sep 2025 22:27:00 +0800</pubDate>
      <guid>http://localhost:49666/2025/09/05/%E9%9D%A2%E5%90%91-scaling-%E7%BC%96%E7%A8%8B/</guid>
      <description>&lt;h1 id=&#34;面向-scaling-编程&#34;&gt;面向 scaling 编程&lt;/h1&gt;&#xA;&lt;p&gt;最近脑子里一直在盘旋着一个观点，所有的设计模式归根结底都是面向scaling编程。&lt;/p&gt;&#xA;&lt;p&gt;最近观察大模型的发展，我深刻意识到一个规律：系统的真正能力往往来源于 scaling，而不仅仅是局部优化。大模型通过算力、参数和数据的持续扩展，才能涌现出复杂的能力和行为。这让我重新审视软件工程和业务研发中的那些&amp;quot;可扩展、可维护、解耦、复用&amp;quot;等目标——表面上看似不同的追求，归根结底都是为系统在规模和复杂度增长时仍能稳定演进而设计。&lt;/p&gt;&#xA;&lt;p&gt;软件从来不是静态的，它会随着业务扩张而膨胀。单机架构到分布式，再到微服务拆分，每一次演进都是在应对规模增长带来的压力；模块化、接口抽象、数据治理、领域建模，则是为团队扩张和业务多线发展预留空间。即便是业务研发流程、需求评审、协作规范，也都是为 scaling 做准备，保证系统和团队在复杂度上升时不至于失控。大模型给我的启发是：当增长到一定阈值后，原本看似微小的设计选择，都会被放大，系统的可演化能力才是真正的核心竞争力。&lt;/p&gt;&#xA;&lt;p&gt;接受了这个观点后，我在日常研发中思考问题的方式也发生了变化。过去我更关注眼前需求和局部优雅，而现在我会先问：如果用户量或功能点增长十倍，代码还能撑住吗？接口和模块的边界设计是否足够稳健？即便是一个小功能，我也会优先考虑它在未来扩展中的弹性。这并非过度设计，而是让系统在初期就为 scaling 留下余地，让代码不仅解决今天的问题，也能支撑明天的增长。&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
