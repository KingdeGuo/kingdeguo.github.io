<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>复杂性管理 on kingdeguo&#39;s blog</title>
    <link>https://www.kingdeguo.com/tags/%E5%A4%8D%E6%9D%82%E6%80%A7%E7%AE%A1%E7%90%86/</link>
    <description>Recent content in 复杂性管理 on kingdeguo&#39;s blog</description>
    <generator>Hugo</generator>
    <language>zh-CN</language>
    <lastBuildDate>Fri, 06 Feb 2026 20:28:00 +0800</lastBuildDate>
    <atom:link href="https://www.kingdeguo.com/tags/%E5%A4%8D%E6%9D%82%E6%80%A7%E7%AE%A1%E7%90%86/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>增加一层抽象，核心是一层</title>
      <link>https://www.kingdeguo.com/2026/02/06/%E5%A2%9E%E5%8A%A0%E4%B8%80%E5%B1%82%E6%8A%BD%E8%B1%A1%E6%A0%B8%E5%BF%83%E6%98%AF%E4%B8%80%E5%B1%82/</link>
      <pubDate>Fri, 06 Feb 2026 20:28:00 +0800</pubDate>
      <guid>https://www.kingdeguo.com/2026/02/06/%E5%A2%9E%E5%8A%A0%E4%B8%80%E5%B1%82%E6%8A%BD%E8%B1%A1%E6%A0%B8%E5%BF%83%E6%98%AF%E4%B8%80%E5%B1%82/</guid>
      <description>&lt;p&gt;在软件工程领域，有一句被反复验证、也被反复引用的话：任何复杂的问题，都可以通过增加一层抽象来解决。&lt;/p&gt;&#xA;&lt;p&gt;这句话之所以流传至今，是因为它在无数真实场景中成立过。模块化、分层架构、接口、平台化，本质上都是这句话的实践形态。&lt;/p&gt;&#xA;&lt;p&gt;很长一段时间里，我对这套逻辑深信不疑。系统一复杂，就抽象；边界一模糊，就加层；变化一频繁，就再包一层。每一次抽象，都会在短期内带来一种确定感：结构更清晰了，职责更明确了，复杂度好像被&amp;quot;管住了&amp;quot;。&lt;/p&gt;&#xA;&lt;p&gt;直到后来我慢慢意识到，真正的问题往往不是抽象不够，而是抽象失控。&lt;/p&gt;&#xA;&lt;p&gt;系统并没有因为不断加层而真正变简单，只是复杂性被分摊、转移、隐藏到了更多地方。每一层单看都合理，但整体却越来越难以理解、难以维护、难以演进。那时我才开始反问自己：我们究竟是在解决复杂性，还是在用抽象推迟面对复杂性？&lt;/p&gt;&#xA;&lt;p&gt;转变并不是发生在某一次失败上，而是来自对&amp;quot;抽象层&amp;quot;这个概念本身的重新理解。&lt;/p&gt;&#xA;&lt;p&gt;过去我默认的认知是：抽象是一种可以不断叠加的能力。问题复杂，就往上再抽一层；还复杂，就继续抽。这个过程似乎没有天然的终点，只要你愿意，总能找到一个更高阶的概念来包住当前的问题。&lt;/p&gt;&#xA;&lt;p&gt;但后来我逐渐意识到，真正关键的并不是&amp;quot;能不能再抽一层&amp;quot;，而是你是否定义了抽象的层次边界。&lt;/p&gt;&#xA;&lt;p&gt;也正是在这里，我的看法发生了根本变化。核心不在于增加抽象，而在于定义一层。这里说的一层，并不是字面意义上的单层结构，而是一种被刻意限制的、有限的层次体系。&lt;/p&gt;&#xA;&lt;p&gt;只有当抽象的层次是有限的，封装和屏蔽才真正成立。如果层次本身是开放的、可无限叠加的，那么所谓&amp;quot;屏蔽细节&amp;quot;，往往只是把细节从一个地方挪到另一个地方。&lt;/p&gt;&#xA;&lt;p&gt;从方法论的角度看，这是两种完全不同的复杂性处理路径。一种，是通过不断增加抽象来对抗复杂性，希望站得足够高，就能看清一切。另一种，是通过限制抽象层次来驯服复杂性，迫使自己在有限层级内做清晰而艰难的取舍。&lt;/p&gt;&#xA;&lt;p&gt;前者更多依赖聪明，后者更多依赖克制。&lt;/p&gt;&#xA;&lt;p&gt;而真正难的，恰恰是后者。因为它要求你在设计之初就直面一些无法回避的问题：哪些变化值得被吸收进系统？哪些变化必须暴露给上层？哪些不确定性是系统的责任，哪些应该留给使用者或业务去承担？这些问题，无法通过&amp;quot;再加一层&amp;quot;来延后。&lt;/p&gt;&#xA;&lt;p&gt;当你真正定义了一层核心层次，抽象才开始变得有重量。&lt;/p&gt;&#xA;&lt;p&gt;这一层往往包含最少的概念，却承载着最重要的承诺。它不追求覆盖所有场景，而是追求长期稳定；不追求极致灵活，而是提供清晰边界。在这一层之下，允许实现快速演化；在这一层之上，允许策略自由组合。但这一层本身，必须足够克制，也必须足够坚定。&lt;/p&gt;&#xA;&lt;p&gt;后来我越来越确信：抽象的目的，从来不是掩盖复杂性，而是约束复杂性。&lt;/p&gt;&#xA;&lt;p&gt;你不是因为抽象了，才理解问题；而是因为已经足够理解问题，才知道该在哪一层抽象，又该在哪一层停下来。&lt;/p&gt;&#xA;&lt;p&gt;所以，当我们再次引用那句经典的话时，也许应该在心里补上一个前提：任何复杂的问题，确实可以通过增加一层抽象来解决——前提是，你清楚这一层是不是最后一层。&lt;/p&gt;&#xA;&lt;p&gt;成熟的方法论，往往不是不断做加法，而是知道什么时候该止步。不是追求层层完美，而是追求长期可理解、可演进的结构稳定性。&lt;/p&gt;&#xA;&lt;p&gt;最终我得到的结论反而很朴素：增加一层抽象，并不困难。真正困难的，是在该停下来的地方，清楚而坚定地停下来。&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
