<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>架构设计 on kingdeguo&#39;s blog</title>
    <link>https://www.kingdeguo.com/tags/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/</link>
    <description>Recent content in 架构设计 on kingdeguo&#39;s blog</description>
    <generator>Hugo</generator>
    <language>zh-CN</language>
    <lastBuildDate>Fri, 06 Feb 2026 20:28:00 +0800</lastBuildDate>
    <atom:link href="https://www.kingdeguo.com/tags/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>增加一层抽象，核心是一层</title>
      <link>https://www.kingdeguo.com/2026/02/06/%E5%A2%9E%E5%8A%A0%E4%B8%80%E5%B1%82%E6%8A%BD%E8%B1%A1%E6%A0%B8%E5%BF%83%E6%98%AF%E4%B8%80%E5%B1%82/</link>
      <pubDate>Fri, 06 Feb 2026 20:28:00 +0800</pubDate>
      <guid>https://www.kingdeguo.com/2026/02/06/%E5%A2%9E%E5%8A%A0%E4%B8%80%E5%B1%82%E6%8A%BD%E8%B1%A1%E6%A0%B8%E5%BF%83%E6%98%AF%E4%B8%80%E5%B1%82/</guid>
      <description>&lt;p&gt;在软件工程领域，有一句被反复验证、也被反复引用的话：任何复杂的问题，都可以通过增加一层抽象来解决。&lt;/p&gt;&#xA;&lt;p&gt;这句话之所以流传至今，是因为它在无数真实场景中成立过。模块化、分层架构、接口、平台化，本质上都是这句话的实践形态。&lt;/p&gt;&#xA;&lt;p&gt;很长一段时间里，我对这套逻辑深信不疑。系统一复杂，就抽象；边界一模糊，就加层；变化一频繁，就再包一层。每一次抽象，都会在短期内带来一种确定感：结构更清晰了，职责更明确了，复杂度好像被&amp;quot;管住了&amp;quot;。&lt;/p&gt;&#xA;&lt;p&gt;直到后来我慢慢意识到，真正的问题往往不是抽象不够，而是抽象失控。&lt;/p&gt;&#xA;&lt;p&gt;系统并没有因为不断加层而真正变简单，只是复杂性被分摊、转移、隐藏到了更多地方。每一层单看都合理，但整体却越来越难以理解、难以维护、难以演进。那时我才开始反问自己：我们究竟是在解决复杂性，还是在用抽象推迟面对复杂性？&lt;/p&gt;&#xA;&lt;p&gt;转变并不是发生在某一次失败上，而是来自对&amp;quot;抽象层&amp;quot;这个概念本身的重新理解。&lt;/p&gt;&#xA;&lt;p&gt;过去我默认的认知是：抽象是一种可以不断叠加的能力。问题复杂，就往上再抽一层；还复杂，就继续抽。这个过程似乎没有天然的终点，只要你愿意，总能找到一个更高阶的概念来包住当前的问题。&lt;/p&gt;&#xA;&lt;p&gt;但后来我逐渐意识到，真正关键的并不是&amp;quot;能不能再抽一层&amp;quot;，而是你是否定义了抽象的层次边界。&lt;/p&gt;&#xA;&lt;p&gt;也正是在这里，我的看法发生了根本变化。核心不在于增加抽象，而在于定义一层。这里说的一层，并不是字面意义上的单层结构，而是一种被刻意限制的、有限的层次体系。&lt;/p&gt;&#xA;&lt;p&gt;只有当抽象的层次是有限的，封装和屏蔽才真正成立。如果层次本身是开放的、可无限叠加的，那么所谓&amp;quot;屏蔽细节&amp;quot;，往往只是把细节从一个地方挪到另一个地方。&lt;/p&gt;&#xA;&lt;p&gt;从方法论的角度看，这是两种完全不同的复杂性处理路径。一种，是通过不断增加抽象来对抗复杂性，希望站得足够高，就能看清一切。另一种，是通过限制抽象层次来驯服复杂性，迫使自己在有限层级内做清晰而艰难的取舍。&lt;/p&gt;&#xA;&lt;p&gt;前者更多依赖聪明，后者更多依赖克制。&lt;/p&gt;&#xA;&lt;p&gt;而真正难的，恰恰是后者。因为它要求你在设计之初就直面一些无法回避的问题：哪些变化值得被吸收进系统？哪些变化必须暴露给上层？哪些不确定性是系统的责任，哪些应该留给使用者或业务去承担？这些问题，无法通过&amp;quot;再加一层&amp;quot;来延后。&lt;/p&gt;&#xA;&lt;p&gt;当你真正定义了一层核心层次，抽象才开始变得有重量。&lt;/p&gt;&#xA;&lt;p&gt;这一层往往包含最少的概念，却承载着最重要的承诺。它不追求覆盖所有场景，而是追求长期稳定；不追求极致灵活，而是提供清晰边界。在这一层之下，允许实现快速演化；在这一层之上，允许策略自由组合。但这一层本身，必须足够克制，也必须足够坚定。&lt;/p&gt;&#xA;&lt;p&gt;后来我越来越确信：抽象的目的，从来不是掩盖复杂性，而是约束复杂性。&lt;/p&gt;&#xA;&lt;p&gt;你不是因为抽象了，才理解问题；而是因为已经足够理解问题，才知道该在哪一层抽象，又该在哪一层停下来。&lt;/p&gt;&#xA;&lt;p&gt;所以，当我们再次引用那句经典的话时，也许应该在心里补上一个前提：任何复杂的问题，确实可以通过增加一层抽象来解决——前提是，你清楚这一层是不是最后一层。&lt;/p&gt;&#xA;&lt;p&gt;成熟的方法论，往往不是不断做加法，而是知道什么时候该止步。不是追求层层完美，而是追求长期可理解、可演进的结构稳定性。&lt;/p&gt;&#xA;&lt;p&gt;最终我得到的结论反而很朴素：增加一层抽象，并不困难。真正困难的，是在该停下来的地方，清楚而坚定地停下来。&lt;/p&gt;</description>
    </item>
    <item>
      <title>大模型到底改变了什么？</title>
      <link>https://www.kingdeguo.com/2025/10/01/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%88%B0%E5%BA%95%E6%94%B9%E5%8F%98%E4%BA%86%E4%BB%80%E4%B9%88/</link>
      <pubDate>Wed, 01 Oct 2025 17:10:00 +0800</pubDate>
      <guid>https://www.kingdeguo.com/2025/10/01/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%88%B0%E5%BA%95%E6%94%B9%E5%8F%98%E4%BA%86%E4%BB%80%E4%B9%88/</guid>
      <description>&lt;h1 id=&#34;大模型到底改变了什么&#34;&gt;大模型到底改变了什么？&lt;/h1&gt;&#xA;&lt;p&gt;最近我常常在想一个问题：大模型到底改变了什么？&lt;/p&gt;&#xA;&lt;p&gt;有时候，我觉得它带来的冲击比表面看到的还要大。以前我们做事，总有一种&amp;quot;节奏感&amp;quot;。比如一个方案要几天准备，一个流程要几周走完，一个文档要一个人慢慢写。时间和空间像是一种自然约束，每个人都被它框住。&lt;/p&gt;&#xA;&lt;p&gt;可大模型出现后，很多节奏突然被打乱了。它能在几分钟里生成一份初稿，能同时处理多个任务，能让原本需要排队、等待、反复确认的事情瞬间推进。以前那种&amp;quot;必须花时间消耗&amp;quot;的逻辑，好像被改写了。&lt;/p&gt;&#xA;&lt;p&gt;这让我想起一句话：尼采说&amp;quot;上帝死了&amp;quot;，意味着旧的秩序崩塌，人必须重新面对世界。而大模型的出现，也像是在提醒我们：很多旧的秩序被抹平了，我们得重新去思考。&lt;/p&gt;&#xA;&lt;p&gt;在工作里，我已经真切感受到这种变化。过去，一个项目提案要靠几个人反复讨论、磨合、再定稿；现在，我自己先丢给模型跑一版资料，立刻就能拿到一个方向，再带着成果和大家讨论，节奏完全不同了。过去，写一封正式的邮件要反复斟酌用词；现在，模型能帮我先列一个框架，我只需要根据场景润色。那种&amp;quot;节奏感&amp;quot;，真的被重构了。&lt;/p&gt;&#xA;&lt;p&gt;我有时候甚至会有点震惊：原本我们以为不可替代的流程、不可压缩的时间，现在突然都变得松动了。这让我不得不重新思考：如果效率不再是瓶颈，那我们该怎么定义自己的价值？如果机器能并行处理一切&amp;quot;可量化&amp;quot;的工作，那我们作为人，还能贡献什么？&lt;/p&gt;&#xA;&lt;p&gt;这些问题我现在还没有答案。但我能确定的是，大模型不是在帮我们省点时间这么简单，而是把我们对&amp;quot;时间、空间和工作节奏&amp;quot;的理解彻底翻了一遍。&lt;/p&gt;&#xA;&lt;p&gt;它让我意识到，我们已经站在一个新的门槛上。很多事情，需要我们重新去看，重新去理解。&lt;/p&gt;</description>
    </item>
    <item>
      <title>员工的 AI 与领导的 AI</title>
      <link>https://www.kingdeguo.com/2025/09/19/%E5%91%98%E5%B7%A5%E7%9A%84-ai-%E4%B8%8E%E9%A2%86%E5%AF%BC%E7%9A%84-ai/</link>
      <pubDate>Fri, 19 Sep 2025 19:24:00 +0800</pubDate>
      <guid>https://www.kingdeguo.com/2025/09/19/%E5%91%98%E5%B7%A5%E7%9A%84-ai-%E4%B8%8E%E9%A2%86%E5%AF%BC%E7%9A%84-ai/</guid>
      <description>&lt;h1 id=&#34;员工的-ai-与领导的-ai&#34;&gt;员工的 AI 与领导的 AI&lt;/h1&gt;&#xA;&lt;p&gt;最近朋友聊起他们团队的情况，讲到 AI 的使用方式，我突然有了新的认知——员工用 AI 和领导用 AI，其实完全不是一回事。员工使用 AI，通常是为了提升个人效率——写文章、写代码、整理资料，它像一把放大镜，让每一项工作更精准、更高效。而领导使用 AI，则更多牵涉组织决策和团队管理，影响更深，也更复杂。&lt;/p&gt;&#xA;&lt;p&gt;朋友描述的一个场景让我印象深刻：领导用 AI 生成了一整套项目方案，直接交给团队执行。表面上看似高效，但团队发现很多内容与实际情况脱节，不得不花额外时间拆解和调整。这让我思考，传统管理方式与 AI 的结合并非天然顺畅。过去的管理强调计划、流程和层级，而 AI 的介入放大了决策的速度，也放大了偏差。当领导依赖 AI 生成指令，却忽略了团队实际执行能力时，组织就可能陷入&amp;quot;表面高效、实则低效&amp;quot;的怪圈。&lt;/p&gt;&#xA;&lt;p&gt;员工 AI 与领导 AI 的差异，也折射出组织运作的核心逻辑。员工 AI 是效率的放大器，让个体工作更精准、可控；领导 AI 则是决策的放大器，它放大的是组织的节奏和方向。如果没有对协作模式、沟通机制和执行能力的深入理解，领导 AI 产生的方案往往难以落地。由此可见，新技术的价值不能脱离组织和协作体系，否则效率提升可能只是表面现象。&lt;/p&gt;&#xA;&lt;p&gt;理性看待 AI 的使用显得尤为重要。员工的 AI 应该作为辅助工具，让个体能力得到放大；领导的 AI 应作为决策参考，让组织节奏更稳健。同时，组织需要在传统管理基础上重构协作方式：明确职责边界、保持沟通畅通、调整反馈机制。只有这样，AI 的加持才能真正转化为团队整体价值。AI 不应成为形式化的指标或考核手段，而应成为增强智慧、支持决策和优化协作的工具。&lt;/p&gt;&#xA;&lt;p&gt;最终，我的思考回到一个核心点：员工的 AI 与领导的 AI 虽然不同，但如果能在组织和协作逻辑下有机结合，就能让效率和弹性同时存在，让团队在快速变化中保持方向感和韧性。正如朋友所说的那些具体场景，如果领导和团队都能理解 AI 的边界和价值，技术带来的改变才会真正扎根，而不是浮在表面。&lt;/p&gt;</description>
    </item>
    <item>
      <title>想法是创造，思考是破坏</title>
      <link>https://www.kingdeguo.com/2025/09/11/%E6%83%B3%E6%B3%95%E6%98%AF%E5%88%9B%E9%80%A0%E6%80%9D%E8%80%83%E6%98%AF%E7%A0%B4%E5%9D%8F/</link>
      <pubDate>Thu, 11 Sep 2025 00:00:00 +0800</pubDate>
      <guid>https://www.kingdeguo.com/2025/09/11/%E6%83%B3%E6%B3%95%E6%98%AF%E5%88%9B%E9%80%A0%E6%80%9D%E8%80%83%E6%98%AF%E7%A0%B4%E5%9D%8F/</guid>
      <description>&lt;h1 id=&#34;想法是创造思考是破坏&#34;&gt;想法是创造，思考是破坏&lt;/h1&gt;&#xA;&lt;p&gt;当我最初听到&amp;quot;想法是创造，思考是破坏&amp;quot;时，下意识觉得它有些偏激。思考怎么会是破坏呢？它不是一直以来都被视为理性与保障吗？可越在软件工程里观察，我越发现这种说法并不夸张，甚至直击核心。&lt;/p&gt;&#xA;&lt;p&gt;想法，是一束火花。它让人兴奋，能瞬间点燃团队的激情，带来新的可能：无论是&amp;quot;上微服务&amp;quot;的豪言，还是&amp;quot;重构一整个模块&amp;quot;的冲动，想法让未来似乎变得触手可及。但火花再亮，如果不经过拆解，就可能点燃的是一堆干草——瞬间燃烧，最终只剩一地灰烬。&lt;/p&gt;&#xA;&lt;p&gt;思考，恰恰是那个看似冷酷的&amp;quot;破坏者&amp;quot;。它不带激情，而是拿着锤子，把闪闪发光的创意逐块敲开，逼我们回答最难听的问题：十倍的流量来了，架构是否能扛住？团队翻倍后，流程是否还能运转？未来方向变了，今天的设计还能存活吗？这种拆解确实残酷，它像是不断推倒沙盘上的模型。但也正是这种破坏，才筛掉了华而不实的幻想，留下了真正能经得住时间考验的方案。&lt;/p&gt;&#xA;&lt;p&gt;走到这里，我对&amp;quot;创造&amp;quot;和&amp;quot;破坏&amp;quot;的理解发生了转变。创造，不只是提出一个点子，而是敢于把未来打开，让可能性出现；破坏，也不是真正意义上的摧毁，而是一种净化，把脆弱和虚幻剔除出去。两者并不是对立，而是互为因果：没有创造，破坏就成了空洞的挑剔；没有破坏，创造也会淹没在复杂度与债务中。&lt;/p&gt;&#xA;&lt;p&gt;所以我慢慢明白，创造和破坏其实是一体的。创造让未来展开，给我们勇气去尝试；破坏让幻想收缩，逼我们留下真实能走下去的部分。就像在软件工程里，一个健康的系统不是靠一连串灵感堆出来的，而是靠无数次推倒、重来、取舍之后，才沉淀成可靠的架构。激情与冷静、点子与质疑，本就该交替出现，这样滚动向前，才算是真正的进化。&lt;/p&gt;</description>
    </item>
    <item>
      <title>面向 scaling 编程</title>
      <link>https://www.kingdeguo.com/2025/09/05/%E9%9D%A2%E5%90%91-scaling-%E7%BC%96%E7%A8%8B/</link>
      <pubDate>Fri, 05 Sep 2025 22:27:00 +0800</pubDate>
      <guid>https://www.kingdeguo.com/2025/09/05/%E9%9D%A2%E5%90%91-scaling-%E7%BC%96%E7%A8%8B/</guid>
      <description>&lt;h1 id=&#34;面向-scaling-编程&#34;&gt;面向 scaling 编程&lt;/h1&gt;&#xA;&lt;p&gt;最近脑子里一直在盘旋着一个观点，所有的设计模式归根结底都是面向scaling编程。&lt;/p&gt;&#xA;&lt;p&gt;最近观察大模型的发展，我深刻意识到一个规律：系统的真正能力往往来源于 scaling，而不仅仅是局部优化。大模型通过算力、参数和数据的持续扩展，才能涌现出复杂的能力和行为。这让我重新审视软件工程和业务研发中的那些&amp;quot;可扩展、可维护、解耦、复用&amp;quot;等目标——表面上看似不同的追求，归根结底都是为系统在规模和复杂度增长时仍能稳定演进而设计。&lt;/p&gt;&#xA;&lt;p&gt;软件从来不是静态的，它会随着业务扩张而膨胀。单机架构到分布式，再到微服务拆分，每一次演进都是在应对规模增长带来的压力；模块化、接口抽象、数据治理、领域建模，则是为团队扩张和业务多线发展预留空间。即便是业务研发流程、需求评审、协作规范，也都是为 scaling 做准备，保证系统和团队在复杂度上升时不至于失控。大模型给我的启发是：当增长到一定阈值后，原本看似微小的设计选择，都会被放大，系统的可演化能力才是真正的核心竞争力。&lt;/p&gt;&#xA;&lt;p&gt;接受了这个观点后，我在日常研发中思考问题的方式也发生了变化。过去我更关注眼前需求和局部优雅，而现在我会先问：如果用户量或功能点增长十倍，代码还能撑住吗？接口和模块的边界设计是否足够稳健？即便是一个小功能，我也会优先考虑它在未来扩展中的弹性。这并非过度设计，而是让系统在初期就为 scaling 留下余地，让代码不仅解决今天的问题，也能支撑明天的增长。&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
