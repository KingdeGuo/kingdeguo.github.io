<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>技术 on kingdeguo&#39;s blog</title>
    <link>https://www.kingdeguo.com/categories/%E6%8A%80%E6%9C%AF/</link>
    <description>Recent content in 技术 on kingdeguo&#39;s blog</description>
    <generator>Hugo</generator>
    <language>zh-CN</language>
    <lastBuildDate>Thu, 30 Oct 2025 12:50:00 +0800</lastBuildDate>
    <atom:link href="https://www.kingdeguo.com/categories/%E6%8A%80%E6%9C%AF/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>用户为结果付费，而不是为过程付费</title>
      <link>https://www.kingdeguo.com/2025/10/30/%E7%94%A8%E6%88%B7%E4%B8%BA%E7%BB%93%E6%9E%9C%E4%BB%98%E8%B4%B9%E8%80%8C%E4%B8%8D%E6%98%AF%E4%B8%BA%E8%BF%87%E7%A8%8B%E4%BB%98%E8%B4%B9/</link>
      <pubDate>Thu, 30 Oct 2025 12:50:00 +0800</pubDate>
      <guid>https://www.kingdeguo.com/2025/10/30/%E7%94%A8%E6%88%B7%E4%B8%BA%E7%BB%93%E6%9E%9C%E4%BB%98%E8%B4%B9%E8%80%8C%E4%B8%8D%E6%98%AF%E4%B8%BA%E8%BF%87%E7%A8%8B%E4%BB%98%E8%B4%B9/</guid>
      <description>&lt;p&gt;前段时间我在想，付费模式的真正精髓是什么？&lt;/p&gt;&#xA;&lt;p&gt;一句话：只需要付费。&lt;/p&gt;&#xA;&lt;p&gt;这五个字，是现代商业中最优雅的承诺。它意味着——用户付完钱，其他一切都不用操心。无需等待、无需学习、无需重复试错。结果自然出现，价值被直接兑现。用户真正购买的，是确定的结果，而不是复杂的过程。&lt;/p&gt;&#xA;&lt;p&gt;回想很多行业的演变，本质上都是从&amp;quot;按过程收费&amp;quot;走向&amp;quot;按结果收费&amp;quot;。装修不再按天计费，而是按交付标准；咨询不再算小时，而是按成效定价；软件订阅也一样——你买的不是代码，而是让问题被解决的能力。过程可以复杂，但用户希望它被隐藏。&lt;/p&gt;&#xA;&lt;p&gt;换句话说，最好的服务，是让用户感受不到服务的存在。&lt;/p&gt;&#xA;&lt;p&gt;这也是为什么我对大模型的按调用、按 token 计费模式一直保留意见。调用次数、token 消耗，并不能代表结果的价值。模型输出的不确定性太高——你可能需要多轮试错、不断提示、反复验证，才能得到一个&amp;quot;可用&amp;quot;的答案。那种体验更像是在&amp;quot;为不确定性买单&amp;quot;。用户最终不是在为智能付费，而是在为混乱埋单。&lt;/p&gt;&#xA;&lt;p&gt;真正持久的商业逻辑，不是计费方式的复杂化，而是结果的标准化。&lt;/p&gt;&#xA;&lt;p&gt;标准化的本质，是把过程的波动压缩成可交付的确定性：固定质量、可复用模板、稳定输出。对大模型产品来说，这意味着——不卖 API，而卖结果。不卖推理能力，而卖可直接使用的&amp;quot;成果&amp;quot;：一份写好的文案、一段合格的代码、一套可上线的方案。&lt;/p&gt;&#xA;&lt;p&gt;标准化，让&amp;quot;只需要付费&amp;quot;变得可能。用户不该被迫理解 token、调用数、提示工程这些中间环节。理想的产品形态，是用户只需付钱，就能获得&amp;quot;已解决的问题&amp;quot;。从付费到结果，路径越短，体验越高级；干扰越少，商业模式越稳固。&lt;/p&gt;&#xA;&lt;p&gt;也许，好的产品就该像水——你不必知道它的流向，只要打开水龙头，它自然会流出来。用户要的不是控制权，而是确定性；不是过程的参与，而是结果的安心。&lt;/p&gt;</description>
    </item>
    <item>
      <title>大模型盈利模式更像传统制造业</title>
      <link>https://www.kingdeguo.com/2025/10/19/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E7%9B%88%E5%88%A9%E6%A8%A1%E5%BC%8F%E6%9B%B4%E5%83%8F%E4%BC%A0%E7%BB%9F%E5%88%B6%E9%80%A0%E4%B8%9A/</link>
      <pubDate>Sun, 19 Oct 2025 14:16:00 +0800</pubDate>
      <guid>https://www.kingdeguo.com/2025/10/19/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E7%9B%88%E5%88%A9%E6%A8%A1%E5%BC%8F%E6%9B%B4%E5%83%8F%E4%BC%A0%E7%BB%9F%E5%88%B6%E9%80%A0%E4%B8%9A/</guid>
      <description>&lt;h1 id=&#34;大模型盈利模式更像传统制造业&#34;&gt;大模型盈利模式更像传统制造业&lt;/h1&gt;&#xA;&lt;p&gt;最近跟几位从事AI的朋友聊，他们都笑着说：&amp;ldquo;你以为我们是在做互联网生意，其实更像在开工厂。&amp;rdquo;&lt;/p&gt;&#xA;&lt;p&gt;一开始我没太在意，还以为他们在夸张。但细想下来，确实如此。大模型的投入、运作和盈利逻辑，跟传统制造业比起来，惊人地像。&lt;/p&gt;&#xA;&lt;p&gt;我们先说投入。大模型不是你上线一个App就能吸引用户那种轻松。无论是搭建算力集群、整理海量训练数据，还是调度工程师团队，每一步都重资产、重成本、重周期。训练一次大型模型，几百万甚至上千万的算力账单就摆在你面前。互联网模式强调零边际成本——用户越多，成本越摊越薄；大模型却是边际递增——用户越多，推理成本越高。你今天多一个请求，就等于多烧一次电、多占一次算力。&lt;/p&gt;&#xA;&lt;p&gt;然后是运营。你以为上线了模型就能坐等流量？不不不，每一次迭代、每一次优化，都像工业生产中的工艺改进。数据清洗像原料加工，模型训练像流水线操作，推理优化像生产线调度。这些听起来枯燥，但决定了公司能不能挣钱。算法创新重要，但稳定、低耗、高产才是护城河。互联网模式讲故事、抓眼球，大模型讲效率和工艺。&lt;/p&gt;&#xA;&lt;p&gt;还有盈利方式。互联网靠流量、广告、长尾效应和网络效应，很多时候是虚拟的规模奇迹。大模型不同，它靠算力、靠数据、靠工程体系的积累。你做得再聪明，如果工业流程没打通，盈利就像沙子在手里漏掉。这也是为什么大模型行业里，有些公司看起来技术领先，但盈利能力却一直不稳。&lt;/p&gt;&#xA;&lt;p&gt;真正的拐点，是从&amp;quot;造模型&amp;quot;到&amp;quot;造体系&amp;quot;。当模型不再是单次训练的精密机器，而是可持续生产、可复用、可扩展的系统时，边际成本才可能被控制，规模效应才开始显现。这时，大模型公司才真正像制造业，不靠故事挣钱，而靠效率和流程赢利。算法、数据、算力、工程团队，都像零件和工序，缺一不可。&lt;/p&gt;&#xA;&lt;p&gt;所以说，大模型不是互联网的延续，它更像工业文明的下一章。表面上是智能革命，实质上是制造升级。喜欢讲投资故事的容易兴奋，但真正挣钱的，永远是那些懂得&amp;quot;把工业流程跑通&amp;quot;的人。&lt;/p&gt;</description>
    </item>
    <item>
      <title>面向 scaling 编程</title>
      <link>https://www.kingdeguo.com/2025/09/05/%E9%9D%A2%E5%90%91-scaling-%E7%BC%96%E7%A8%8B/</link>
      <pubDate>Fri, 05 Sep 2025 22:27:00 +0800</pubDate>
      <guid>https://www.kingdeguo.com/2025/09/05/%E9%9D%A2%E5%90%91-scaling-%E7%BC%96%E7%A8%8B/</guid>
      <description>&lt;h1 id=&#34;面向-scaling-编程&#34;&gt;面向 scaling 编程&lt;/h1&gt;&#xA;&lt;p&gt;最近脑子里一直在盘旋着一个观点，所有的设计模式归根结底都是面向scaling编程。&lt;/p&gt;&#xA;&lt;p&gt;最近观察大模型的发展，我深刻意识到一个规律：系统的真正能力往往来源于 scaling，而不仅仅是局部优化。大模型通过算力、参数和数据的持续扩展，才能涌现出复杂的能力和行为。这让我重新审视软件工程和业务研发中的那些&amp;quot;可扩展、可维护、解耦、复用&amp;quot;等目标——表面上看似不同的追求，归根结底都是为系统在规模和复杂度增长时仍能稳定演进而设计。&lt;/p&gt;&#xA;&lt;p&gt;软件从来不是静态的，它会随着业务扩张而膨胀。单机架构到分布式，再到微服务拆分，每一次演进都是在应对规模增长带来的压力；模块化、接口抽象、数据治理、领域建模，则是为团队扩张和业务多线发展预留空间。即便是业务研发流程、需求评审、协作规范，也都是为 scaling 做准备，保证系统和团队在复杂度上升时不至于失控。大模型给我的启发是：当增长到一定阈值后，原本看似微小的设计选择，都会被放大，系统的可演化能力才是真正的核心竞争力。&lt;/p&gt;&#xA;&lt;p&gt;接受了这个观点后，我在日常研发中思考问题的方式也发生了变化。过去我更关注眼前需求和局部优雅，而现在我会先问：如果用户量或功能点增长十倍，代码还能撑住吗？接口和模块的边界设计是否足够稳健？即便是一个小功能，我也会优先考虑它在未来扩展中的弹性。这并非过度设计，而是让系统在初期就为 scaling 留下余地，让代码不仅解决今天的问题，也能支撑明天的增长。&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
